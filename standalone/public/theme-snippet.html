<!-- 
  AI Visual Generator v2 - é¦–é¡µé¢„åŠ è½½ + ç¬¬äºŒå¼ å›¾æ›¿æ¢
  
  ä½¿ç”¨æ–¹æ³•ï¼š
  1. å¤åˆ¶ä¸‹é¢çš„ <script> æ ‡ç­¾å†…å®¹
  2. ç²˜è´´åˆ° Shopify ä¸»é¢˜çš„ theme.liquid æ–‡ä»¶ä¸­ï¼Œæ”¾åœ¨ </body> ä¹‹å‰
  3. æ ¹æ®ä½ çš„ä¸»é¢˜è°ƒæ•´ productCardSelector é€‰æ‹©å™¨
  
  åŠŸèƒ½ç‰¹ç‚¹ï¼š
  - åœ¨é¦–é¡µ/é›†åˆé¡µå°±å¼€å§‹é¢„åŠ è½½ AI ç”Ÿæˆå›¾ç‰‡
  - ä½¿ç”¨ç¬¬ä¸€å¼ äº§å“å›¾ï¼ˆæ¸…æ™°è£¸å›¾ï¼‰ä½œä¸ºç´ æ
  - ç”Ÿæˆç»“æœæ›¿æ¢åˆ°ç¬¬äºŒå¼ å›¾ä½ç½®
  - æ”¯æŒå¤šäº§å“å¹¶è¡Œç”Ÿæˆ
  - Hover æ—¶æ˜¾ç¤º AI ç”Ÿæˆçš„å›¾ç‰‡
  - äº§å“è¯¦æƒ…é¡µå¤ç”¨å·²ç”Ÿæˆçš„ç¼“å­˜
-->

<script>
    (function () {
        'use strict';

        const CONFIG = {
            apiUrl: 'https://shopify-ai-script-production.up.railway.app/api',
            // é¦–é¡µäº§å“å¡ç‰‡é€‰æ‹©å™¨ï¼ˆé€‚é…å¸¸è§ä¸»é¢˜ï¼Œæ ¹æ®å®é™…ä¸»é¢˜è°ƒæ•´ï¼‰
            productCardSelector: [
                '.product-card-wrapper',  // Dawn ä¸»é¢˜
                '.card-wrapper',          // Dawn ä¸»é¢˜å¤‡é€‰
                '.card--standard',        // Dawn å¡ç‰‡
                '.product-card',
                '.product-item',
                '.grid__item[class*="product"]',
                '.collection-product-card',
                '.card--product',
                'product-card',
            ].join(', '),
            // äº§å“è¯¦æƒ…é¡µåª’ä½“å®¹å™¨é€‰æ‹©å™¨
            productMediaContainerSelector: '.product__media-list, .product__media-wrapper, .product-media-container, .product__photos, .product-single__photos, .product__media-gallery, .product-gallery, media-gallery',
            // äº§å“è¯¦æƒ…é¡µå•ä¸ªåª’ä½“é¡¹é€‰æ‹©å™¨
            productMediaItemSelector: '.product__media-item, .product-media, .product__photo-wrapper, li[data-media-id], .media-gallery__item, .product__media-item--image',
            // Banner/Hero Image é€‰æ‹©å™¨
            bannerSelector: '.banner__media img, .hero-banner img, .slideshow__image, .hero__image img, .image-hero img',
            // Collection Image é€‰æ‹©å™¨
            collectionImageSelector: '.collection-card-wrapper img, .collection-list__item img, .collection-hero img, .collection__image img',
            // Image with Text é€‰æ‹©å™¨
            imageWithTextSelector: '.image-with-text__media img, .image-with-text__media-item img, .image-with-text img',
            maxConcurrent: 8,  // æœ€å¤§å¹¶å‘ç”Ÿæˆæ•°ï¼ˆå¯è°ƒæ•´ï¼š4-12ï¼‰
            timeout: 60000,
            debug: true,
            // ä½¿ç”¨ sessionStorage è·¨é¡µé¢ç¼“å­˜
            useSessionCache: true,
        };

        const log = (...args) => { if (CONFIG.debug) console.log('[AI Visual]', ...args); };

        // ç”ŸæˆçŠ¶æ€ç®¡ç†ï¼ˆå†…å­˜ç¼“å­˜ï¼‰
        const generationState = new Map(); // key -> { status, imageUrl, targetImg }

        // =====================
        // UTM å‚æ•°æŒä¹…åŒ–ï¼ˆè·¨é¡µé¢ä¿ç•™ UTMï¼‰
        // =====================

        const UTM_STORAGE_KEY = 'ai_visual_utm';
        const UTM_SESSION_KEY = 'ai_visual_utm_session'; // æ ‡è®°å½“å‰ä¼šè¯æ˜¯å¦æœ‰ UTM

        /**
         * æ£€æŸ¥æ˜¯å¦æ˜¯ç«™å†…è·³è½¬ï¼ˆreferrer æ˜¯åŒç«™ï¼‰
         */
        function isInternalNavigation() {
            const referrer = document.referrer;
            if (!referrer) return false;
            try {
                const referrerHost = new URL(referrer).hostname;
                const currentHost = window.location.hostname;
                return referrerHost === currentHost;
            } catch {
                return false;
            }
        }

        /**
         * ä» sessionStorage è·å– UTM å‚æ•°
         */
        function getUtmFromSession() {
            try {
                const data = sessionStorage.getItem(UTM_STORAGE_KEY);
                if (!data) return null;
                return JSON.parse(data);
            } catch {
                return null;
            }
        }

        /**
         * æ£€æŸ¥å½“å‰ä¼šè¯æ˜¯å¦å·²ç»æœ‰è¿‡ UTMï¼ˆç”¨äºåˆ¤æ–­ç«™å†…è·³è½¬æ—¶æ˜¯å¦åº”è¯¥ä½¿ç”¨å­˜å‚¨çš„ UTMï¼‰
         */
        function hasUtmSession() {
            return sessionStorage.getItem(UTM_SESSION_KEY) === 'true';
        }

        /**
         * ä¿å­˜ UTM å‚æ•°åˆ° sessionStorage
         * å®Œå…¨è¦†ç›–ï¼šéƒ¨åˆ† UTM æ—¶ï¼Œæ²¡æœ‰çš„å­—æ®µç•™ç©º
         */
        function saveUtmToSession() {
            const params = new URLSearchParams(window.location.search);
            const utmSource = params.get('utm_source');
            const utmMedium = params.get('utm_medium');
            const utmCampaign = params.get('utm_campaign');
            const utmContent = params.get('utm_content');
            const utmTerm = params.get('utm_term');

            log('ğŸ” saveUtmToSession called:', {
                urlHasUtm: !!(utmSource || utmCampaign),
                utmSource,
                utmCampaign,
                isInternal: isInternalNavigation(),
                currentSession: sessionStorage.getItem(UTM_SESSION_KEY),
                currentUtm: sessionStorage.getItem(UTM_STORAGE_KEY)
            });

            // åªæœ‰å½“ URL ä¸­æœ‰ UTM å‚æ•°æ—¶æ‰ä¿å­˜
            if (utmSource || utmCampaign) {
                // å®Œå…¨è¦†ç›–ï¼Œæ²¡æœ‰çš„å­—æ®µå°±æ˜¯ null
                const utmData = {
                    utmSource: utmSource || null,
                    utmMedium: utmMedium || null,
                    utmCampaign: utmCampaign || null,
                    utmContent: utmContent || null,
                    utmTerm: utmTerm || null,
                };
                try {
                    sessionStorage.setItem(UTM_STORAGE_KEY, JSON.stringify(utmData));
                    sessionStorage.setItem(UTM_SESSION_KEY, 'true'); // æ ‡è®°æ­¤ä¼šè¯æœ‰ UTM
                    log('ğŸ“¦ UTM saved to session:', utmData);
                } catch (e) {
                    log('âŒ UTM save error:', e);
                }
            } else if (!isInternalNavigation()) {
                // å¤–éƒ¨è¿›å…¥ä¸”æ²¡æœ‰ UTM â†’ æ¸…é™¤ä¹‹å‰çš„ UTMï¼ˆæ–°è®¿é—®ï¼‰
                sessionStorage.removeItem(UTM_STORAGE_KEY);
                sessionStorage.removeItem(UTM_SESSION_KEY);
                log('ğŸ—‘ï¸ External visit without UTM, cleared session');
            } else {
                log('ğŸ“ Internal navigation without UTM, keeping session');
            }
        }

        // é¡µé¢åŠ è½½æ—¶ç«‹å³å¤„ç† UTM
        saveUtmToSession();

        // =====================
        // SessionStorage ç¼“å­˜ï¼ˆè·¨é¡µé¢æŒä¹…åŒ–ï¼‰
        // =====================

        const CACHE_KEY = 'ai_visual_cache';
        const CACHE_TTL = 30 * 60 * 1000; // 30 åˆ†é’Ÿè¿‡æœŸ

        function getSessionCache() {
            if (!CONFIG.useSessionCache) return {};
            try {
                const data = sessionStorage.getItem(CACHE_KEY);
                if (!data) return {};
                const parsed = JSON.parse(data);
                // æ¸…ç†è¿‡æœŸç¼“å­˜
                const now = Date.now();
                Object.keys(parsed).forEach(key => {
                    if (parsed[key].timestamp && now - parsed[key].timestamp > CACHE_TTL) {
                        delete parsed[key];
                    }
                });
                return parsed;
            } catch {
                return {};
            }
        }

        function setSessionCache(key, imageUrl) {
            if (!CONFIG.useSessionCache) return;
            try {
                const cache = getSessionCache();
                cache[key] = { imageUrl, timestamp: Date.now() };
                sessionStorage.setItem(CACHE_KEY, JSON.stringify(cache));
            } catch (e) {
                log('Cache write error:', e);
            }
        }

        function getCachedUrl(key) {
            const cache = getSessionCache();
            return cache[key]?.imageUrl || null;
        }

        // ç”ŸæˆåŒ…å« UTM ä¿¡æ¯çš„ç¼“å­˜ Key
        function getUtmCacheKey(baseKey) {
            const utm = getUtmParams();
            const utmPart = [
                utm.utmSource || '',
                utm.utmCampaign || '',
                utm.utmContent || '',
                utm.utmTerm || '',
            ].filter(Boolean).join('_') || 'direct';
            return `${baseKey}__${utmPart}`;
        }

        // æ³¨å…¥ CSS åŠ¨ç”»æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
        @keyframes ai-shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes ai-pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        @keyframes ai-reveal {
            0% { clip-path: inset(0 100% 0 0); }
            100% { clip-path: inset(0 0 0 0); }
        }
        
        .ai-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.03);
            overflow: hidden;
            pointer-events: none;
            z-index: 10;
        }
        
        /* ç§»é™¤æ–‡å­—æç¤ºï¼Œåªä¿ç•™ shimmer æ•ˆæœ */
        
        .ai-loading-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255,255,255,0.4) 50%,
                transparent 100%
            );
            animation: ai-shimmer 1.5s ease-in-out infinite;
        }
        
        .ai-reveal {
            animation: ai-reveal 0.8s ease-out forwards;
        }
        
        .ai-generated-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 12px;
            z-index: 5;
            pointer-events: none;
            opacity: 0.9;
        }
        
        /* äº§å“å¡ç‰‡ç¬¬äºŒå¼ å›¾çš„å®¹å™¨æ ·å¼ */
        .ai-secondary-image-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .product-card:hover .ai-secondary-image-wrapper,
        .card--product:hover .ai-secondary-image-wrapper,
        [class*="product"]:hover .ai-secondary-image-wrapper {
            opacity: 1;
        }
    `;
        document.head.appendChild(style);

        // =====================
        // å·¥å…·å‡½æ•°
        // =====================

        function getUtmParams() {
            // ä¼˜å…ˆä» URL è¯»å–
            const params = new URLSearchParams(window.location.search);
            const urlUtmSource = params.get('utm_source');
            const urlUtmCampaign = params.get('utm_campaign');

            // å¦‚æœ URL æœ‰ UTM å‚æ•°ï¼Œä½¿ç”¨ URL çš„
            if (urlUtmSource || urlUtmCampaign) {
                return {
                    utmSource: urlUtmSource || undefined,
                    utmMedium: params.get('utm_medium') || undefined,
                    utmCampaign: urlUtmCampaign || undefined,
                    utmContent: params.get('utm_content') || undefined,
                    utmTerm: params.get('utm_term') || undefined,
                };
            }

            // è°ƒè¯•ï¼šæ£€æŸ¥æ¡ä»¶
            const isInternal = isInternalNavigation();
            const hasSession = hasUtmSession();
            const savedUtm = getUtmFromSession();
            log('ğŸ” UTM check:', { isInternal, hasSession, savedUtm, referrer: document.referrer });

            // åªæœ‰ã€Œç«™å†…è·³è½¬ + æ­¤ä¼šè¯æœ‰è¿‡ UTMã€æ—¶æ‰ä» sessionStorage è¯»å–
            if (isInternal && hasSession && savedUtm) {
                log('ğŸ“‚ Using UTM from session (internal navigation):', savedUtm);
                return {
                    utmSource: savedUtm.utmSource || undefined,
                    utmMedium: savedUtm.utmMedium || undefined,
                    utmCampaign: savedUtm.utmCampaign || undefined,
                    utmContent: savedUtm.utmContent || undefined,
                    utmTerm: savedUtm.utmTerm || undefined,
                };
            }

            // æ²¡æœ‰ä»»ä½• UTM å‚æ•°
            return {
                utmSource: undefined,
                utmMedium: undefined,
                utmCampaign: undefined,
                utmContent: undefined,
                utmTerm: undefined,
            };
        }

        function getTimeContext() {
            const now = new Date();
            const hour = now.getHours();
            const month = now.getMonth();
            let timeOfDay = hour >= 5 && hour < 12 ? 'morning' : hour >= 12 && hour < 17 ? 'afternoon' : hour >= 17 && hour < 21 ? 'evening' : 'night';
            let season = month >= 2 && month <= 4 ? 'spring' : month >= 5 && month <= 7 ? 'summer' : month >= 8 && month <= 10 ? 'autumn' : 'winter';
            return { timeOfDay, season, clientTime: now.toISOString() };
        }

        function shouldProcess() {
            const utm = getUtmParams();
            const referrer = document.referrer || '';
            if (utm.utmSource || utm.utmCampaign) return true;
            return ['instagram', 'tiktok', 'facebook', 'google'].some(p => referrer.toLowerCase().includes(p));
        }

        function getProductHandleFromCard(card) {
            const link = card.querySelector('a[href*="/products/"]');
            if (!link) return null;
            const match = link.getAttribute('href')?.match(/\/products\/([^?#\/]+)/);
            return match ? match[1] : null;
        }

        function getProductHandleFromUrl() {
            const match = window.location.pathname.match(/\/products\/([^?#\/]+)/);
            return match ? match[1] : null;
        }

        function getCollectionInfo() {
            // ä» URL è·å– collection handle
            const urlMatch = window.location.pathname.match(/\/collections\/([^?#\/]+)/);
            const collectionHandle = urlMatch ? urlMatch[1] : null;

            // ä» Shopify Analytics è·å–
            const shopifyCollection = window.ShopifyAnalytics?.meta?.page?.pageType === 'collection'
                ? window.ShopifyAnalytics.meta.page
                : null;

            // ä» DOM è·å– collection æ ‡é¢˜
            const titleElement = document.querySelector('.collection-hero__title, .collection__title, h1.title, .page-header__title');
            const collectionTitle = titleElement?.textContent?.trim() || null;

            // ä» DOM è·å– collection æè¿°
            const descElement = document.querySelector('.collection-hero__description, .collection__description, .rte');
            const collectionDescription = descElement?.textContent?.trim()?.slice(0, 200) || null;

            // è·å–é¡µé¢ä¸Šçš„äº§å“åç§°åˆ—è¡¨
            const productNames = [];
            const productCards = document.querySelectorAll('.product-card-wrapper, .card-wrapper, .product-card');
            productCards.forEach(card => {
                const nameEl = card.querySelector('.card__heading, .product-card__title, .card-information__text, h3 a');
                if (nameEl) {
                    const name = nameEl.textContent?.trim();
                    if (name && productNames.length < 5) {  // æœ€å¤šå–5ä¸ª
                        productNames.push(name);
                    }
                }
            });

            const info = {
                handle: collectionHandle,
                title: collectionTitle || collectionHandle?.replace(/-/g, ' '),
                description: collectionDescription,
                productNames: productNames,
                productCount: productCards.length,
            };

            log('Collection info:', info);
            return info;
        }

        // =====================
        // API è¯·æ±‚
        // =====================

        async function generateImage(imageUrl, imageType, productName = '') {
            return generateImageWithContext(imageUrl, imageType, { productName });
        }

        async function generateImageWithContext(imageUrl, imageType, extraContext = {}) {
            const context = {
                ...getUtmParams(),
                referrer: document.referrer,
                ...getTimeContext(),
                ...extraContext,
            };
            log('Generating:', { imageUrl, imageType, context });

            try {
                const response = await fetch(`${CONFIG.apiUrl}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ imageUrl, imageType, ...context }),
                });
                const data = await response.json();
                log('Result:', data);
                return data.success ? data.imageUrl : null;
            } catch (error) {
                console.error('[AI Visual] Error:', error);
                return null;
            }
        }

        // =====================
        // é¦–é¡µäº§å“å¡ç‰‡å¤„ç†
        // =====================

        function findProductCards() {
            // é¦–å…ˆå°è¯•é…ç½®çš„é€‰æ‹©å™¨
            let cards = document.querySelectorAll(CONFIG.productCardSelector);

            if (cards.length === 0) {
                // å°è¯•æ›´å¤šé€šç”¨é€‰æ‹©å™¨
                const fallbackSelectors = [
                    // Dawn ä¸»é¢˜
                    '.product-card-wrapper',
                    '.card-wrapper',
                    // å…¶ä»–å¸¸è§ä¸»é¢˜
                    '.grid-product',
                    '.product-grid-item',
                    '.product-index',
                    '.product-block',
                    '.collection-product',
                    // é€šç”¨æ¨¡å¼ï¼šåŒ…å«äº§å“é“¾æ¥çš„å¡ç‰‡
                    '[class*="product"][class*="card"]',
                    '[class*="product"][class*="item"]',
                    '.grid__item a[href*="/products/"]',
                    // æ›´å®½æ¾çš„åŒ¹é…
                    'a[href*="/products/"]',
                ];

                for (const selector of fallbackSelectors) {
                    try {
                        const found = document.querySelectorAll(selector);
                        if (found.length > 0) {
                            log(`Found ${found.length} cards with fallback selector: ${selector}`);
                            // å¦‚æœæ˜¯é“¾æ¥ï¼Œæ‰¾åˆ°å…¶çˆ¶å®¹å™¨
                            if (selector.includes('a[href')) {
                                cards = Array.from(found).map(a => {
                                    // å‘ä¸Šæ‰¾åˆ°åˆé€‚çš„å¡ç‰‡å®¹å™¨
                                    let parent = a.parentElement;
                                    for (let i = 0; i < 5 && parent; i++) {
                                        if (parent.querySelector('img')) {
                                            return parent;
                                        }
                                        parent = parent.parentElement;
                                    }
                                    return a.parentElement;
                                });
                                // å»é‡
                                cards = [...new Set(cards)];
                            } else {
                                cards = found;
                            }
                            break;
                        }
                    } catch (e) {
                        // æŸäº›é€‰æ‹©å™¨å¯èƒ½æ— æ•ˆ
                    }
                }
            }

            log(`Found ${cards.length} product cards`);

            // è°ƒè¯•ï¼šæ˜¾ç¤ºæ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªå¡ç‰‡çš„ç±»å
            if (cards.length > 0) {
                const firstCard = cards[0];
                log('First card classes:', firstCard.className);
                log('First card tag:', firstCard.tagName);
            } else {
                log('ğŸ’¡ No product cards found. Check your theme\'s HTML structure.');
                log('ğŸ’¡ Look for elements containing product links like: a[href*="/products/"]');
            }

            return Array.from(cards);
        }

        function getCardImages(card) {
            // å°è¯•å¤šç§é€‰æ‹©å™¨æ‰¾åˆ°å›¾ç‰‡ï¼ˆDawn ä¸»é¢˜ä¼˜å…ˆï¼‰
            const imgSelectors = [
                '.card__media .media img',     // Dawn ä¸»é¢˜
                '.card__media img',            // Dawn ä¸»é¢˜å¤‡é€‰
                '.media--hover-effect img',    // Dawn hover æ•ˆæœå›¾ç‰‡
                '.product-card__image img',
                '.product-card-wrapper img',
                '.media img',
                'img[srcset]',
                'img',
            ];

            for (const selector of imgSelectors) {
                const imgs = card.querySelectorAll(selector);
                if (imgs.length > 0) {
                    log(`Found ${imgs.length} images with selector: ${selector}`);
                    return Array.from(imgs);
                }
            }
            return [];
        }

        function addLoadingOverlay(element) {
            const parent = element.parentElement;
            if (!parent || parent.querySelector('.ai-loading-overlay')) return null;

            const pos = getComputedStyle(parent).position;
            if (pos === 'static') parent.style.position = 'relative';

            const overlay = document.createElement('div');
            overlay.className = 'ai-loading-overlay';
            parent.appendChild(overlay);
            return overlay;
        }

        function createSecondaryImageSlot(card, primaryImg) {
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç¬¬äºŒå¼ å›¾æˆ–æˆ‘ä»¬åˆ›å»ºçš„ wrapper
            const existingWrapper = card.querySelector('.ai-secondary-image-wrapper');
            if (existingWrapper) return existingWrapper.querySelector('img');

            const imgs = getCardImages(card);
            if (imgs.length >= 2) {
                // å·²æœ‰ç¬¬äºŒå¼ å›¾ï¼Œç›´æ¥ä½¿ç”¨
                return imgs[1];
            }

            // åˆ›å»ºç¬¬äºŒå¼ å›¾çš„å®¹å™¨
            const imgContainer = primaryImg.closest('.card__media, .product-card__image, .media') || primaryImg.parentElement;
            if (!imgContainer) return null;

            const pos = getComputedStyle(imgContainer).position;
            if (pos === 'static') imgContainer.style.position = 'relative';

            const wrapper = document.createElement('div');
            wrapper.className = 'ai-secondary-image-wrapper';

            const newImg = document.createElement('img');
            newImg.className = 'ai-generated-image';
            newImg.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
            newImg.alt = 'AI Generated';

            wrapper.appendChild(newImg);
            imgContainer.appendChild(wrapper);

            return newImg;
        }

        async function processProductCard(card, index) {
            const productHandle = getProductHandleFromCard(card);
            if (!productHandle) {
                log('No product handle found for card', index);
                return;
            }

            // æ£€æŸ¥æ˜¯å¦å·²å¤„ç†
            if (generationState.has(productHandle)) {
                log('Already processing/processed:', productHandle);
                return;
            }

            const imgs = getCardImages(card);
            if (imgs.length === 0) {
                log('No images found in card:', productHandle);
                return;
            }

            const primaryImg = imgs[0];
            const originalSrc = primaryImg.src || primaryImg.dataset.src || primaryImg.currentSrc;

            if (!originalSrc || !originalSrc.startsWith('http')) {
                log('Invalid image src:', originalSrc);
                return;
            }

            // è·å–æˆ–åˆ›å»ºç¬¬äºŒå¼ å›¾çš„ä½ç½®
            const secondaryImg = createSecondaryImageSlot(card, primaryImg);
            if (!secondaryImg) {
                log('Could not create secondary image slot');
                return;
            }

            // è®¾ç½®çŠ¶æ€
            generationState.set(productHandle, {
                status: 'loading',
                imageUrl: null,
                targetImg: secondaryImg,
                card: card,
            });

            // æ·»åŠ  loading çŠ¶æ€åˆ°ç¬¬äºŒå¼ å›¾
            const overlay = addLoadingOverlay(secondaryImg);

            // æ£€æŸ¥ sessionStorage ç¼“å­˜ï¼ˆåŒ…å« UTM ä¿¡æ¯ï¼‰
            const cacheKey = getUtmCacheKey(productHandle);
            const cachedUrl = getCachedUrl(cacheKey);
            if (cachedUrl) {
                log(`Using cached image for: ${cacheKey}`);
                if (overlay) overlay.remove();  // ç«‹å³ç§»é™¤ loading
                applyImageToTarget(cachedUrl, secondaryImg, null, productHandle, true);  // skipAnimation = true
                generationState.set(productHandle, { status: 'done', imageUrl: cachedUrl });
                return;
            }

            log(`Starting generation for: ${productHandle} (cache key: ${cacheKey})`);

            try {
                // ä½¿ç”¨ç¬¬ä¸€å¼ å›¾ï¼ˆæ¸…æ™°è£¸å›¾ï¼‰ä½œä¸ºç´ æ
                const newUrl = await generateImage(originalSrc, 'product', productHandle);

                if (newUrl) {
                    // ä¿å­˜åˆ°å†…å­˜å’Œ sessionStorageï¼ˆä½¿ç”¨åŒ…å« UTM çš„ keyï¼‰
                    generationState.set(productHandle, {
                        status: 'done',
                        imageUrl: newUrl,
                        targetImg: secondaryImg,
                    });
                    setSessionCache(cacheKey, newUrl);

                    applyImageToTarget(newUrl, secondaryImg, overlay, productHandle);
                } else {
                    if (overlay) overlay.remove();
                    generationState.set(productHandle, { status: 'error' });
                }
            } catch (error) {
                if (overlay) overlay.remove();
                generationState.set(productHandle, { status: 'error' });
                log('Error:', error);
            }
        }

        function applyImageToTarget(newUrl, targetImg, overlay, logName, skipAnimation = false) {
            log(`Attempting to apply image to ${logName}...`);
            log(`Target img element:`, targetImg);
            log(`New URL:`, newUrl);

            if (!targetImg) {
                log(`âŒ Target image element is null/undefined for ${logName}`);
                if (overlay) overlay.remove();
                return;
            }

            const preload = new Image();
            preload.crossOrigin = 'anonymous';  // å°è¯•å¤„ç† CORS

            preload.onload = () => {
                log(`âœ… Image preloaded successfully for ${logName}`);
                if (overlay) overlay.remove();

                // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„ srcset
                targetImg.removeAttribute('srcset');
                targetImg.removeAttribute('data-srcset');

                // æ¸…é™¤ picture source
                const picture = targetImg.closest('picture');
                if (picture) {
                    picture.querySelectorAll('source').forEach(s => s.remove());
                    log(`Removed picture sources`);
                }

                // è®¾ç½®æ–°å›¾ç‰‡
                const oldSrc = targetImg.src;
                targetImg.src = newUrl;
                log(`Image src changed: ${oldSrc?.slice(0, 40)}... â†’ ${newUrl.slice(0, 40)}...`);

                // ç¼“å­˜å‘½ä¸­æ—¶ä¸æ˜¾ç¤ºåŠ¨ç”»
                if (!skipAnimation) {
                    targetImg.classList.add('ai-reveal');
                }

                // æ˜¾ç¤º wrapperï¼ˆå¦‚æœæ˜¯æˆ‘ä»¬åˆ›å»ºçš„ï¼‰
                const wrapper = targetImg.closest('.ai-secondary-image-wrapper');
                if (wrapper) {
                    wrapper.style.opacity = '0'; // hover æ—¶æ‰æ˜¾ç¤º
                    log(`Set wrapper opacity to 0 (hover to show)`);
                }

                log(`âœ… Applied image for ${logName}`);
            };

            preload.onerror = (e) => {
                if (overlay) overlay.remove();
                log(`âŒ Failed to load generated image for ${logName}`);
                log(`Error event:`, e);
                log(`Attempted URL:`, newUrl);

                // å°è¯•ç›´æ¥è®¾ç½®ï¼ˆä¸é¢„åŠ è½½ï¼‰
                log(`Attempting direct src set without preload...`);
                targetImg.src = newUrl;
            };

            preload.src = newUrl;
        }

        async function processAllProductCards() {
            const cards = findProductCards();
            if (cards.length === 0) {
                log('No product cards found on page');
                return;
            }

            log(`Processing ${cards.length} product cards...`);

            // å¹¶è¡Œå¤„ç†ï¼Œä½†é™åˆ¶å¹¶å‘æ•°
            const chunks = [];
            for (let i = 0; i < cards.length; i += CONFIG.maxConcurrent) {
                chunks.push(cards.slice(i, i + CONFIG.maxConcurrent));
            }

            for (const chunk of chunks) {
                await Promise.all(chunk.map((card, i) => processProductCard(card, i)));
            }

            log('All product cards processed');
        }

        // =====================
        // Banner/Hero Image å¤„ç†
        // =====================

        async function processBannerImages() {
            const banners = document.querySelectorAll(CONFIG.bannerSelector);
            if (banners.length === 0) {
                log('No banner images found');
                return;
            }

            log(`Found ${banners.length} banner images`);

            // Banner é€šå¸¸åªæœ‰ 1-2 ä¸ªï¼Œå…¨éƒ¨å¹¶è¡Œå¤„ç†
            await Promise.all(Array.from(banners).map((img, index) => processBannerImage(img, index)));
        }

        async function processBannerImage(img, index) {
            if (img.dataset.aiProcessed) return;
            img.dataset.aiProcessed = 'true';

            const originalSrc = img.src || img.dataset.src || img.currentSrc;
            if (!originalSrc?.startsWith('http')) return;

            // ç¼“å­˜ Key åŒ…å« UTM ä¿¡æ¯
            const baseCacheKey = `banner_${index}_${originalSrc.slice(-50)}`;
            const cacheKey = getUtmCacheKey(baseCacheKey);

            // æ£€æŸ¥ç¼“å­˜
            const cachedUrl = getCachedUrl(cacheKey);
            if (cachedUrl) {
                log(`Using cached banner image ${index} (${cacheKey})`);
                applyBannerImage(img, cachedUrl, true);  // skipAnimation = true
                return;
            }

            const overlay = addLoadingOverlay(img);
            log(`Processing banner ${index} (cache key: ${cacheKey})...`);

            try {
                const newUrl = await generateImage(originalSrc, 'banner', `banner_${index}`);

                if (newUrl) {
                    setSessionCache(cacheKey, newUrl);  // ä½¿ç”¨åŒ…å« UTM çš„ key
                    if (overlay) overlay.remove();
                    applyBannerImage(img, newUrl);
                    log(`âœ… Banner ${index} updated`);
                } else {
                    if (overlay) overlay.remove();
                }
            } catch (error) {
                if (overlay) overlay.remove();
                log('Banner error:', error);
            }
        }

        function applyBannerImage(img, newUrl, skipAnimation = false) {
            log(`Applying banner image...`);

            const preload = new Image();
            preload.crossOrigin = 'anonymous';

            preload.onload = () => {
                log(`âœ… Banner image preloaded`);
                img.removeAttribute('srcset');
                img.removeAttribute('data-srcset');

                const picture = img.closest('picture');
                if (picture) {
                    picture.querySelectorAll('source').forEach(s => s.remove());
                }

                if (!skipAnimation) {
                    img.classList.add('ai-reveal');
                }
                img.src = newUrl;
                log(`âœ… Banner image applied`);
            };

            preload.onerror = (e) => {
                log(`âŒ Banner image preload failed, trying direct set...`);
                img.src = newUrl;
            };

            preload.src = newUrl;
        }

        // =====================
        // Collection Image å¤„ç†
        // =====================

        async function processCollectionImages() {
            const collectionImgs = document.querySelectorAll(CONFIG.collectionImageSelector);
            if (collectionImgs.length === 0) {
                log('No collection images found');
                return;
            }

            log(`Found ${collectionImgs.length} collection images`);

            // è·å– Collection ä¿¡æ¯
            const collectionInfo = getCollectionInfo();

            await Promise.all(Array.from(collectionImgs).map((img, index) =>
                processCollectionImage(img, index, collectionInfo)
            ));
        }

        async function processCollectionImage(img, index, collectionInfo) {
            if (img.dataset.aiProcessed) return;
            img.dataset.aiProcessed = 'true';

            const originalSrc = img.src || img.dataset.src || img.currentSrc;
            if (!originalSrc?.startsWith('http')) return;

            const baseCacheKey = `collection_${collectionInfo.handle || index}_${originalSrc.slice(-30)}`;
            const cacheKey = getUtmCacheKey(baseCacheKey);

            // æ£€æŸ¥ç¼“å­˜
            const cachedUrl = getCachedUrl(cacheKey);
            if (cachedUrl) {
                log(`Using cached collection image ${index}`);
                applyGenericImage(img, cachedUrl, true);
                return;
            }

            const overlay = addLoadingOverlay(img);
            log(`Processing collection ${index} with info:`, collectionInfo);

            try {
                // ä¼ é€’ collection ä¿¡æ¯ç»™ API
                const newUrl = await generateImageWithContext(originalSrc, 'collection', {
                    collectionTitle: collectionInfo.title,
                    collectionDescription: collectionInfo.description,
                    productNames: collectionInfo.productNames,
                    productCount: collectionInfo.productCount,
                });

                if (newUrl) {
                    setSessionCache(cacheKey, newUrl);
                    if (overlay) overlay.remove();
                    applyGenericImage(img, newUrl);
                    log(`âœ… Collection ${index} updated`);
                } else {
                    if (overlay) overlay.remove();
                }
            } catch (error) {
                if (overlay) overlay.remove();
                log('Collection error:', error);
            }
        }

        // =====================
        // Image with Text å¤„ç†
        // =====================

        async function processImageWithTextImages() {
            const images = document.querySelectorAll(CONFIG.imageWithTextSelector);
            if (images.length === 0) {
                log('No image-with-text images found');
                return;
            }

            log(`Found ${images.length} image-with-text images`);
            await Promise.all(Array.from(images).map((img, index) => processGenericImage(img, 'imageWithText', index)));
        }

        // =====================
        // é€šç”¨å›¾ç‰‡å¤„ç†ï¼ˆCollection, Image with Text ç­‰ï¼‰
        // =====================

        async function processGenericImage(img, type, index) {
            if (img.dataset.aiProcessed) return;
            img.dataset.aiProcessed = 'true';

            const originalSrc = img.src || img.dataset.src || img.currentSrc;
            if (!originalSrc?.startsWith('http')) return;

            const baseCacheKey = `${type}_${index}_${originalSrc.slice(-50)}`;
            const cacheKey = getUtmCacheKey(baseCacheKey);

            // æ£€æŸ¥ç¼“å­˜
            const cachedUrl = getCachedUrl(cacheKey);
            if (cachedUrl) {
                log(`Using cached ${type} image ${index}`);
                applyGenericImage(img, cachedUrl, true);
                return;
            }

            const overlay = addLoadingOverlay(img);
            log(`Processing ${type} ${index} (cache key: ${cacheKey})...`);

            try {
                const newUrl = await generateImage(originalSrc, 'banner', `${type}_${index}`);

                if (newUrl) {
                    setSessionCache(cacheKey, newUrl);
                    if (overlay) overlay.remove();
                    applyGenericImage(img, newUrl);
                    log(`âœ… ${type} ${index} updated`);
                } else {
                    if (overlay) overlay.remove();
                }
            } catch (error) {
                if (overlay) overlay.remove();
                log(`${type} error:`, error);
            }
        }

        function applyGenericImage(img, newUrl, skipAnimation = false) {
            const preload = new Image();
            preload.crossOrigin = 'anonymous';

            preload.onload = () => {
                img.removeAttribute('srcset');
                img.removeAttribute('data-srcset');

                const picture = img.closest('picture');
                if (picture) {
                    picture.querySelectorAll('source').forEach(s => s.remove());
                }

                if (!skipAnimation) {
                    img.classList.add('ai-reveal');
                }
                img.src = newUrl;
            };

            preload.onerror = () => {
                img.src = newUrl;
            };

            preload.src = newUrl;
        }

        // =====================
        // äº§å“è¯¦æƒ…é¡µå¤„ç†
        // =====================

        function findProductDetailImages() {
            // å°è¯•å¤šç§å®¹å™¨é€‰æ‹©å™¨ï¼ˆDawn ä¸»é¢˜ä¼˜å…ˆï¼‰
            const containerSelectors = [
                '.product__media-list',           // Dawn ä¸»é¢˜
                '.product__media-wrapper',        // Dawn ä¸»é¢˜
                'media-gallery',                  // Dawn custom element
                'slider-component',               // Dawn slider
                '.product__media-gallery',
                '.product-gallery',
                '.product__images',
                '.product-images',
                '[data-product-media-container]',
                '.product-single__media-wrapper',
                CONFIG.productMediaContainerSelector,
            ];

            let container = null;
            for (const selector of containerSelectors) {
                container = document.querySelector(selector);
                if (container) {
                    log('Found product media container:', selector);
                    break;
                }
            }

            if (!container) {
                // æœ€åå°è¯•ï¼šæ‰¾åŒ…å«å¤šä¸ªäº§å“å›¾ç‰‡çš„å®¹å™¨
                const allProductImgs = document.querySelectorAll('[class*="product"] img, [data-product] img');
                log('Fallback: found', allProductImgs.length, 'product images');
                if (allProductImgs.length >= 2) {
                    return {
                        primary: allProductImgs[0],
                        secondary: allProductImgs[1],
                    };
                }
                log('No product media container found');
                return { primary: null, secondary: null };
            }

            // å°è¯•å¤šç§åª’ä½“é¡¹é€‰æ‹©å™¨
            const mediaItemSelectors = [
                CONFIG.productMediaItemSelector,
                '.product__media-item',
                '.product-media-item',
                '.media-gallery__item',
                'li[data-media-id]',
                '.product__media > *',
            ];

            let mediaItems = [];
            for (const selector of mediaItemSelectors) {
                mediaItems = container.querySelectorAll(selector);
                if (mediaItems.length >= 2) {
                    log('Found media items with:', selector, 'count:', mediaItems.length);
                    break;
                }
            }

            if (mediaItems.length < 2) {
                // ç›´æ¥æ‰¾å›¾ç‰‡
                const allImgs = container.querySelectorAll('img');
                log('Direct image search in container, found:', allImgs.length);
                return {
                    primary: allImgs[0] || null,
                    secondary: allImgs[1] || null,
                };
            }

            const primaryImg = mediaItems[0]?.querySelector('img');
            const secondaryImg = mediaItems[1]?.querySelector('img');

            log('Primary img:', primaryImg?.src?.slice(0, 50));
            log('Secondary img:', secondaryImg?.src?.slice(0, 50));

            return { primary: primaryImg, secondary: secondaryImg };
        }

        async function processProductDetailPage() {
            log('Processing product detail page...');

            const productHandle = getProductHandleFromUrl();
            if (!productHandle) {
                log('âŒ Could not extract product handle from URL');
                return;
            }
            log('Product handle:', productHandle);

            // å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜
            const existing = generationState.get(productHandle);
            if (existing?.status === 'done' && existing.imageUrl) {
                log('Using memory cached result for:', productHandle);
                applyToDetailPage(existing.imageUrl);
                return;
            }

            // å†æ£€æŸ¥ sessionStorage ç¼“å­˜ï¼ˆè·¨é¡µé¢æŒä¹…åŒ–ï¼ŒåŒ…å« UTMï¼‰
            const cacheKey = getUtmCacheKey(productHandle);
            const cachedUrl = getCachedUrl(cacheKey);
            if (cachedUrl) {
                log('Using session cached result for:', cacheKey);
                applyToDetailPage(cachedUrl, true);  // skipAnimation = true
                return;
            }

            log('No cache found, searching for product images...');
            const { primary, secondary } = findProductDetailImages();

            if (!primary) {
                log('âŒ No primary image found on detail page');
                log('ğŸ’¡ Check if productMediaContainerSelector matches your theme');
                return;
            }

            if (!secondary) {
                log('âŒ No secondary image found on detail page');
                log('ğŸ’¡ This product may only have 1 image - need at least 2');
                return;
            }

            log('âœ… Found primary and secondary images');

            const originalSrc = primary.src || primary.dataset.src || primary.currentSrc;
            if (!originalSrc?.startsWith('http')) return;

            // æ·»åŠ  loading
            const overlay = addLoadingOverlay(secondary);

            log(`Processing detail page: ${productHandle}`);

            try {
                const newUrl = await generateImage(originalSrc, 'product', productHandle);

                if (newUrl) {
                    // ä¿å­˜åˆ°å†…å­˜å’Œ sessionStorageï¼ˆä½¿ç”¨åŒ…å« UTM çš„ keyï¼‰
                    generationState.set(productHandle, { status: 'done', imageUrl: newUrl });
                    setSessionCache(cacheKey, newUrl);

                    log(`Applying to detail page secondary image...`);
                    const preload = new Image();
                    preload.crossOrigin = 'anonymous';

                    preload.onload = () => {
                        log(`âœ… Detail page image preloaded`);
                        if (overlay) overlay.remove();

                        // æ¸…é™¤ srcset é¿å…è¦†ç›–
                        secondary.removeAttribute('srcset');
                        secondary.removeAttribute('data-srcset');

                        const picture = secondary.closest('picture');
                        if (picture) {
                            picture.querySelectorAll('source').forEach(s => s.remove());
                        }

                        secondary.classList.add('ai-reveal');
                        secondary.src = newUrl;

                        log(`âœ… Detail page updated for ${productHandle}`);
                    };

                    preload.onerror = (e) => {
                        log(`âŒ Detail page image preload failed, trying direct set...`);
                        if (overlay) overlay.remove();
                        secondary.src = newUrl;
                    };

                    preload.src = newUrl;
                } else {
                    if (overlay) overlay.remove();
                }
            } catch (error) {
                if (overlay) overlay.remove();
                log('Error on detail page:', error);
            }
        }

        function applyToDetailPage(imageUrl, skipAnimation = false) {
            const { secondary } = findProductDetailImages();
            if (!secondary) {
                log('Cannot apply to detail page: secondary image not found');
                return;
            }

            secondary.removeAttribute('srcset');
            secondary.removeAttribute('data-srcset');

            const picture = secondary.closest('picture');
            if (picture) {
                picture.querySelectorAll('source').forEach(s => s.remove());
            }

            if (!skipAnimation) {
                secondary.classList.add('ai-reveal');
            }
            secondary.src = imageUrl;
            log('Applied AI image to detail page (skipAnimation:', skipAnimation, ')');
        }

        // =====================
        // å…¥å£
        // =====================

        function init() {
            log('AI Visual v2 checking conditions...');
            log('URL:', window.location.href);
            log('Referrer:', document.referrer);
            log('UTM params:', getUtmParams());

            if (!shouldProcess()) {
                log('âŒ No UTM/referrer detected, skipping AI generation');
                log('ğŸ’¡ Tip: Add ?utm_source=test to URL to test');
                return;
            }

            log('âœ… AI Visual v2 initializing...');

            const isProductPage = window.location.pathname.includes('/products/');
            const isHomePage = window.location.pathname === '/' || window.location.pathname === '';
            const isCollectionPage = window.location.pathname.includes('/collections/');

            log('Page type:', { isHomePage, isCollectionPage, isProductPage });

            // æ”¶é›†æ‰€æœ‰éœ€è¦æ‰§è¡Œçš„ä»»åŠ¡
            const tasks = [];

            // é¦–é¡µæˆ–é›†åˆé¡µï¼šå¤„ç†äº§å“å¡ç‰‡ã€Bannerã€Collectionã€Image with Text
            if (isHomePage || isCollectionPage || !isProductPage) {
                tasks.push(processAllProductCards());
                tasks.push(processBannerImages());
                tasks.push(processCollectionImages());      // Collection å›¾ç‰‡
                tasks.push(processImageWithTextImages());   // Image with Text å›¾ç‰‡
                // å…¨éƒ¨å¹¶è¡Œæ‰§è¡Œï¼
            }

            // äº§å“è¯¦æƒ…é¡µï¼šå¤„ç†è¯¦æƒ…å›¾
            if (isProductPage) {
                tasks.push(processProductDetailPage());
            }

            // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰ä»»åŠ¡
            Promise.all(tasks).then(() => {
                log('All processing complete');
            });
        }

        // ç­‰å¾… DOM å’Œå›¾ç‰‡åŠ è½½
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => setTimeout(init, 300));
        } else {
            setTimeout(init, 300);
        }

        // ç›‘å¬ SPA è·¯ç”±å˜åŒ–ï¼ˆShopify æœ‰äº›ä¸»é¢˜ç”¨ AJAXï¼‰
        let lastUrl = location.href;
        new MutationObserver(() => {
            if (location.href !== lastUrl) {
                lastUrl = location.href;
                log('URL changed, re-initializing...');
                setTimeout(init, 500);
            }
        }).observe(document.body, { subtree: true, childList: true });

    })();
</script>